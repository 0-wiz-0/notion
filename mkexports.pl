#
# An ugly kludge to automatically generate exported function registration
# code from source.
#

%objs;
%exports;
%chnds;

if($#ARGV<2){
	print "Usage: mkexports.pl module files...\n";
	exit;
}

$module=$ARGV[0];
$dest=$ARGV[1];
shift @ARGV;
shift @ARGV;

sub desc2ct
{
    my $d=$_[0];
    if($d eq "v"){
	$ct="void";
    }elsif($d eq "i"){
	$ct="int";
    }elsif($d eq "d"){
	$ct="double";
    }elsif($d eq "b"){
	$ct="bool";
    }elsif($d eq "t"){
	$ct="ExtlTab";
    }elsif($d eq "f"){
	$ct="ExtlFn";
    }elsif($d eq "o"){
	$ct="WObj*";
    }elsif($d eq "s"){
	$ct="char *";
    }
}

sub add_obj
{
    # Is there a "unique" function for arrays?
    $objs{$_[0]}=1;
}

sub add_l2_chnd
{
    my $od=$_[0], $ds=$_[1], @ts=@{$_[2]};
    $ds=lc($ds);
    $od=lc($od);
    
    $str="l2chnd_${od}_${ds}__" . join("_",  @ts);
    
    $chnds{$str}=[$od, $ds, @ts];

    return $str;
}

sub get_t
{
    my $const=0;
    my $v=$_[0];
    my $d="?";
    my $t="";
    
    if($v=~s/(^|\s)const(\s|\*)/ /){
	$const=1;
	#print("-->const\n");
    }
    $v=~s/ \*/*/g;
    $v=~s/\s+/ /g;
    $v=~s/^\s+//g;
    
    #print "|$v|\n";
    
    if($v=~/^char\*/){
	if($const){
	  $d="S";
	}else{
	    $d="s";
	}
    }
    elsif($v=~/^int( |$)/){
	$d="i";
    }
    elsif($v=~/^uint( |$)/){
	$d="i";
    }
    elsif($v=~/^void( |$)/){
	$d="v";
    }
    elsif($v=~/^double( |$)/){
	$d="d";
    }
    elsif($v=~/^bool( |$)/){
	$d="b";
    }
    elsif($v=~/^ExtlTab( |$)/){
	$d="t";
    }
    elsif($v=~/^ExtlFn( |$)/){
	$d="f";
    }
    elsif($v=~/^(W.*)\*/){
	add_obj($1);
	$t="$1";
	$d="o";
    }else{
	print "\"$_[0]\" not understood.\n";
	exit(0);
    }
    
    #print "--> $t $d\n";
    
    return ($d, $t);
}

print "Scanning source for exports...\n";

while(<>){
    next unless /^\s*EXTL_EXPORT(\s|$)/;
    $l=$1;
    $a="";
    Loop: {
	do{
	    if($l=~/(.*)\{/)
	    {
		$a=$a . $1;
		last;
	    }
	    $a=$a . $l;
        }while($l=<>);
    };
	
    $a=~s/\n/ /g; 
    $a=~s/\s+/ /g;
    $a=~s/^\s+//g;
    
    print "Processing \"$a\"\n";
    
    $a=~/^([a-zA-Z0-9_ *]+(\*|\s))([a-zA-Z0-9_]+) *\((.*)\)/;
    
    $rv=$1;
    $fn=$3;
    
    @a=split(/,/, $4);
    
    #print "$rv : $fn \n";
    
    ($od, $ot) = get_t($rv);
    
    $k=0;
    @ts=();
    $ds="";
    $comma="";
    $has_ts=0;
    foreach $i(@a) {
	#print "$i\n";
	($d, $t) = get_t($i);
	
	push @ts, $t;
	
	$ds="$ds$d";
	$comma=", ";
    }
    
    $chnd=add_l2_chnd($od, $ds, ts);

    #print "($od, $ot) $fn ($ds)\n";
    #print "Found $fn ($od<-$ds)\n";
    
    #print ">>$od:$ds\n";
    
    $exports{$fn}=[$od, $ds, $chnd];
}

open H, ">$dest";

print H << "END";
/* Automatically generated by mkexports.pl */
#include <ioncore/common.h>
#include <ioncore/extl.h>
#include <ioncore/objp.h>

static bool fail(int ndx, WObj *o, const char *s)
{
    warn("Type checking failed in level 2 call handler for parameter %d "
	 "(got %s, expected %s).", ndx, WOBJ_TYPESTR(o), s);
    return FALSE;
}

END
  
for $obj(keys %objs){
    print H "INTROBJ($obj);\n";
}

print H "\n";


foreach $ch(keys %chnds){
    ($od, $ds, @ts)=@{$chnds{$ch}};
    $oct=desc2ct($od);
    
    print H << "END";
static bool $ch($oct (*fn)(), ExtlL2Param *in, ExtlL2Param *out)
{
END
    # Generate type checking code
    for($k=0; $k<=$#ts; $k=$k+1){
	$str=$ts[$k];
	if($str ne ""){
	    print H "    if(!WOBJ_IS(in[$k].o, $str)){ return fail($k, in[$k].o, \"$str\"); }\n";
	}
    }

    # Generate function call code
    if("$od" eq "v"){
	print H "    fn("
    }else{
	print H "    out[0].${od}=fn("
    }
    
    $comma="";
    @a=split(/ */, $ds);
    for ($k=0; $k<=$#a; $k=$k+1){
	$d=$a[$k];
	print H "${comma}in[$k].$d";
	$comma=", ";
    }
    print H ");\n";
    print H << "END";
    return TRUE;
}
END

}

print H "\n";

foreach $fn(keys %exports){
	print H "extern void $fn();\n";
}

print H << "END";

static ExtlExportedFnSpec ${module}_exports[] = {
END

foreach $fn(keys %exports){
    ($od, $ds, $chnd)=@{$exports{$fn}};
    if($od eq "v"){
	$ods=NULL;
    }else{
	$ods="\"$od\"";
    }
    if($ds eq ""){
	$dss=NULL;
    }else{
	$dss="\"$ds\"";
    }
    print H "    {\"$fn\", $fn, $dss, $ods, (ExtlL2CallHandler*)$chnd},\n";
}

print H << "END"
	{NULL, NULL, NULL, NULL, NULL}
};

bool ${module}_register_exports()
{
    int i;
    for(i=0; ${module}_exports[i].fn; i++){
        extl_register_function(${module}_exports+i);
    }
    return TRUE;
}

void ${module}_unregister_exports()
{
    int i;
    for(i=0; ${module}_exports[i].fn; i++){
        extl_unregister_function(${module}_exports+i);
    }
}
END


